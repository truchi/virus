// ðŸš¨ This file is generated by generate.sh

#![allow(clippy::redundant_closure_call)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::match_single_binding)]
#![allow(clippy::clone_on_copy)]

use serde::{Deserialize, Serialize};

///  Error types.
pub mod error {
    ///  Error from a TryFrom or FromStr implementation.
    pub struct ConversionError(std::borrow::Cow<'static, str>);
    impl std::error::Error for ConversionError {}
    impl std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
            std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
            std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
/// Represents an `and`type (e.g. TextDocumentParams & WorkDoneProgressParams`).
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents an `and`type (e.g. TextDocumentParams & WorkDoneProgressParams`).\",
///   \"type\": \"object\",
///   \"required\": [
///     \"items\",
///     \"kind\"
///   ],
///   \"properties\": {
///     \"items\": {
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Type\"
///       }
///     },
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"and\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AndType {
    pub items: Vec<Type>,
    pub kind: String,
}
impl From<&AndType> for AndType {
    fn from(value: &AndType) -> Self {
        value.clone()
    }
}
/// Represents an array type (e.g. `TextDocument[]`).
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents an array type (e.g. `TextDocument[]`).\",
///   \"type\": \"object\",
///   \"required\": [
///     \"element\",
///     \"kind\"
///   ],
///   \"properties\": {
///     \"element\": {
///       \"$ref\": \"#/definitions/Type\"
///     },
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"array\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ArrayType {
    pub element: Type,
    pub kind: String,
}
impl From<&ArrayType> for ArrayType {
    fn from(value: &ArrayType) -> Self {
        value.clone()
    }
}
/// Represents a base type like `string` or `DocumentUri`.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a base type like `string` or `DocumentUri`.\",
///   \"type\": \"object\",
///   \"required\": [
///     \"kind\",
///     \"name\"
///   ],
///   \"properties\": {
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"base\"
///     },
///     \"name\": {
///       \"$ref\": \"#/definitions/BaseTypes\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BaseType {
    pub kind: String,
    pub name: BaseTypes,
}
impl From<&BaseType> for BaseType {
    fn from(value: &BaseType) -> Self {
        value.clone()
    }
}
/// BaseTypes
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"type\": \"string\",
///   \"enum\": [
///     \"URI\",
///     \"DocumentUri\",
///     \"integer\",
///     \"uinteger\",
///     \"decimal\",
///     \"RegExp\",
///     \"string\",
///     \"boolean\",
///     \"null\"
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BaseTypes {
    #[serde(rename = "URI")]
    Uri,
    DocumentUri,
    #[serde(rename = "integer")]
    Integer,
    #[serde(rename = "uinteger")]
    Uinteger,
    #[serde(rename = "decimal")]
    Decimal,
    RegExp,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "null")]
    Null,
}
impl From<&BaseTypes> for BaseTypes {
    fn from(value: &BaseTypes) -> Self {
        value.clone()
    }
}
impl ToString for BaseTypes {
    fn to_string(&self) -> String {
        match *self {
            Self::Uri => "URI".to_string(),
            Self::DocumentUri => "DocumentUri".to_string(),
            Self::Integer => "integer".to_string(),
            Self::Uinteger => "uinteger".to_string(),
            Self::Decimal => "decimal".to_string(),
            Self::RegExp => "RegExp".to_string(),
            Self::String => "string".to_string(),
            Self::Boolean => "boolean".to_string(),
            Self::Null => "null".to_string(),
        }
    }
}
impl std::str::FromStr for BaseTypes {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "URI" => Ok(Self::Uri),
            "DocumentUri" => Ok(Self::DocumentUri),
            "integer" => Ok(Self::Integer),
            "uinteger" => Ok(Self::Uinteger),
            "decimal" => Ok(Self::Decimal),
            "RegExp" => Ok(Self::RegExp),
            "string" => Ok(Self::String),
            "boolean" => Ok(Self::Boolean),
            "null" => Ok(Self::Null),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for BaseTypes {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaseTypes {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BaseTypes {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
/// Represents a boolean literal type (e.g. `kind: true`).
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a boolean literal type (e.g. `kind: true`).\",
///   \"type\": \"object\",
///   \"required\": [
///     \"kind\",
///     \"value\"
///   ],
///   \"properties\": {
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"booleanLiteral\"
///     },
///     \"value\": {
///       \"type\": \"boolean\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BooleanLiteralType {
    pub kind: String,
    pub value: bool,
}
impl From<&BooleanLiteralType> for BooleanLiteralType {
    fn from(value: &BooleanLiteralType) -> Self {
        value.clone()
    }
}
/// Defines an enumeration.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Defines an enumeration.\",
///   \"type\": \"object\",
///   \"required\": [
///     \"name\",
///     \"type\",
///     \"values\"
///   ],
///   \"properties\": {
///     \"deprecated\": {
///       \"description\": \"Whether the enumeration is deprecated or not. If deprecated the property contains the deprecation message.\",
///       \"type\": \"string\"
///     },
///     \"documentation\": {
///       \"description\": \"An optional documentation.\",
///       \"type\": \"string\"
///     },
///     \"name\": {
///       \"description\": \"The name of the enumeration.\",
///       \"type\": \"string\"
///     },
///     \"proposed\": {
///       \"description\": \"Whether this is a proposed enumeration. If omitted, the enumeration is final.\",
///       \"type\": \"boolean\"
///     },
///     \"since\": {
///       \"description\": \"Since when (release number) this enumeration is available. Is undefined if not known.\",
///       \"type\": \"string\"
///     },
///     \"supportsCustomValues\": {
///       \"description\": \"Whether the enumeration supports custom values (e.g. values which are not part of the set defined in `values`). If omitted no custom values are supported.\",
///       \"type\": \"boolean\"
///     },
///     \"type\": {
///       \"description\": \"The type of the elements.\",
///       \"$ref\": \"#/definitions/EnumerationType\"
///     },
///     \"values\": {
///       \"description\": \"The enum values.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/EnumerationEntry\"
///       }
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Enumeration {
    /// Whether the enumeration is deprecated or not. If deprecated the property contains the deprecation message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<String>,
    /// An optional documentation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
    /// The name of the enumeration.
    pub name: String,
    /// Whether this is a proposed enumeration. If omitted, the enumeration is final.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proposed: Option<bool>,
    /// Since when (release number) this enumeration is available. Is undefined if not known.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
    /// Whether the enumeration supports custom values (e.g. values which are not part of the set defined in `values`). If omitted no custom values are supported.
    #[serde(
        rename = "supportsCustomValues",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub supports_custom_values: Option<bool>,
    /// The type of the elements.
    #[serde(rename = "type")]
    pub type_: EnumerationType,
    /// The enum values.
    pub values: Vec<EnumerationEntry>,
}
impl From<&Enumeration> for Enumeration {
    fn from(value: &Enumeration) -> Self {
        value.clone()
    }
}
/// Defines an enumeration entry.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Defines an enumeration entry.\",
///   \"type\": \"object\",
///   \"required\": [
///     \"name\",
///     \"value\"
///   ],
///   \"properties\": {
///     \"deprecated\": {
///       \"description\": \"Whether the enum entry is deprecated or not. If deprecated the property contains the deprecation message.\",
///       \"type\": \"string\"
///     },
///     \"documentation\": {
///       \"description\": \"An optional documentation.\",
///       \"type\": \"string\"
///     },
///     \"name\": {
///       \"description\": \"The name of the enum item.\",
///       \"type\": \"string\"
///     },
///     \"proposed\": {
///       \"description\": \"Whether this is a proposed enumeration entry. If omitted, the enumeration entry is final.\",
///       \"type\": \"boolean\"
///     },
///     \"since\": {
///       \"description\": \"Since when (release number) this enumeration entry is available. Is undefined if not known.\",
///       \"type\": \"string\"
///     },
///     \"value\": {
///       \"description\": \"The value.\",
///       \"type\": [
///         \"string\",
///         \"number\"
///       ]
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct EnumerationEntry {
    /// Whether the enum entry is deprecated or not. If deprecated the property contains the deprecation message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<String>,
    /// An optional documentation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
    /// The name of the enum item.
    pub name: String,
    /// Whether this is a proposed enumeration entry. If omitted, the enumeration entry is final.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proposed: Option<bool>,
    /// Since when (release number) this enumeration entry is available. Is undefined if not known.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
    /// The value.
    pub value: EnumerationEntryValue,
}
impl From<&EnumerationEntry> for EnumerationEntry {
    fn from(value: &EnumerationEntry) -> Self {
        value.clone()
    }
}
/// The value.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"The value.\",
///   \"type\": [
///     \"string\",
///     \"number\"
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum EnumerationEntryValue {
    Number(f64),
    String(String),
}
impl From<&EnumerationEntryValue> for EnumerationEntryValue {
    fn from(value: &EnumerationEntryValue) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for EnumerationEntryValue {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Number(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::String(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for EnumerationEntryValue {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for EnumerationEntryValue {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for EnumerationEntryValue {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for EnumerationEntryValue {
    fn to_string(&self) -> String {
        match self {
            Self::Number(x) => x.to_string(),
            Self::String(x) => x.to_string(),
        }
    }
}
impl From<f64> for EnumerationEntryValue {
    fn from(value: f64) -> Self {
        Self::Number(value)
    }
}
/// EnumerationType
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"type\": \"object\",
///   \"required\": [
///     \"kind\",
///     \"name\"
///   ],
///   \"properties\": {
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"base\"
///     },
///     \"name\": {
///       \"type\": \"string\",
///       \"enum\": [
///         \"string\",
///         \"integer\",
///         \"uinteger\"
///       ]
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct EnumerationType {
    pub kind: String,
    pub name: EnumerationTypeName,
}
impl From<&EnumerationType> for EnumerationType {
    fn from(value: &EnumerationType) -> Self {
        value.clone()
    }
}
/// EnumerationTypeName
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"type\": \"string\",
///   \"enum\": [
///     \"string\",
///     \"integer\",
///     \"uinteger\"
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum EnumerationTypeName {
    #[serde(rename = "string")]
    String,
    #[serde(rename = "integer")]
    Integer,
    #[serde(rename = "uinteger")]
    Uinteger,
}
impl From<&EnumerationTypeName> for EnumerationTypeName {
    fn from(value: &EnumerationTypeName) -> Self {
        value.clone()
    }
}
impl ToString for EnumerationTypeName {
    fn to_string(&self) -> String {
        match *self {
            Self::String => "string".to_string(),
            Self::Integer => "integer".to_string(),
            Self::Uinteger => "uinteger".to_string(),
        }
    }
}
impl std::str::FromStr for EnumerationTypeName {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "string" => Ok(Self::String),
            "integer" => Ok(Self::Integer),
            "uinteger" => Ok(Self::Uinteger),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for EnumerationTypeName {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for EnumerationTypeName {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for EnumerationTypeName {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
/// IntegerLiteralType
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"type\": \"object\",
///   \"required\": [
///     \"kind\",
///     \"value\"
///   ],
///   \"properties\": {
///     \"kind\": {
///       \"description\": \"Represents an integer literal type (e.g. `kind: 1`).\",
///       \"type\": \"string\",
///       \"const\": \"integerLiteral\"
///     },
///     \"value\": {
///       \"type\": \"number\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IntegerLiteralType {
    /// Represents an integer literal type (e.g. `kind: 1`).
    pub kind: String,
    pub value: f64,
}
impl From<&IntegerLiteralType> for IntegerLiteralType {
    fn from(value: &IntegerLiteralType) -> Self {
        value.clone()
    }
}
/// Represents a type that can be used as a key in a map type. If a reference type is used then the type must either resolve to a `string` or `integer` type. (e.g. `type ChangeAnnotationIdentifier === string`).
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a type that can be used as a key in a map type. If a reference type is used then the type must either resolve to a `string` or `integer` type. (e.g. `type ChangeAnnotationIdentifier === string`).\",
///   \"anyOf\": [
///     {
///       \"type\": \"object\",
///       \"required\": [
///         \"kind\",
///         \"name\"
///       ],
///       \"properties\": {
///         \"kind\": {
///           \"type\": \"string\",
///           \"const\": \"base\"
///         },
///         \"name\": {
///           \"type\": \"string\",
///           \"enum\": [
///             \"URI\",
///             \"DocumentUri\",
///             \"string\",
///             \"integer\"
///           ]
///         }
///       },
///       \"additionalProperties\": false
///     },
///     {
///       \"$ref\": \"#/definitions/ReferenceType\"
///     }
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum MapKeyType {
    Variant0 {
        kind: String,
        name: MapKeyTypeVariant0Name,
    },
    Variant1(ReferenceType),
}
impl From<&MapKeyType> for MapKeyType {
    fn from(value: &MapKeyType) -> Self {
        value.clone()
    }
}
impl From<ReferenceType> for MapKeyType {
    fn from(value: ReferenceType) -> Self {
        Self::Variant1(value)
    }
}
/// MapKeyTypeVariant0Name
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"type\": \"string\",
///   \"enum\": [
///     \"URI\",
///     \"DocumentUri\",
///     \"string\",
///     \"integer\"
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MapKeyTypeVariant0Name {
    #[serde(rename = "URI")]
    Uri,
    DocumentUri,
    #[serde(rename = "string")]
    String,
    #[serde(rename = "integer")]
    Integer,
}
impl From<&MapKeyTypeVariant0Name> for MapKeyTypeVariant0Name {
    fn from(value: &MapKeyTypeVariant0Name) -> Self {
        value.clone()
    }
}
impl ToString for MapKeyTypeVariant0Name {
    fn to_string(&self) -> String {
        match *self {
            Self::Uri => "URI".to_string(),
            Self::DocumentUri => "DocumentUri".to_string(),
            Self::String => "string".to_string(),
            Self::Integer => "integer".to_string(),
        }
    }
}
impl std::str::FromStr for MapKeyTypeVariant0Name {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "URI" => Ok(Self::Uri),
            "DocumentUri" => Ok(Self::DocumentUri),
            "string" => Ok(Self::String),
            "integer" => Ok(Self::Integer),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for MapKeyTypeVariant0Name {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MapKeyTypeVariant0Name {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MapKeyTypeVariant0Name {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
/// Represents a JSON object map (e.g. `interface Map<K extends string | integer, V> { [key: K] => V; }`).
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a JSON object map (e.g. `interface Map<K extends string | integer, V> { [key: K] => V; }`).\",
///   \"type\": \"object\",
///   \"required\": [
///     \"key\",
///     \"kind\",
///     \"value\"
///   ],
///   \"properties\": {
///     \"key\": {
///       \"$ref\": \"#/definitions/MapKeyType\"
///     },
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"map\"
///     },
///     \"value\": {
///       \"$ref\": \"#/definitions/Type\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MapType {
    pub key: MapKeyType,
    pub kind: String,
    pub value: Box<Type>,
}
impl From<&MapType> for MapType {
    fn from(value: &MapType) -> Self {
        value.clone()
    }
}
/// Indicates in which direction a message is sent in the protocol.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Indicates in which direction a message is sent in the protocol.\",
///   \"type\": \"string\",
///   \"enum\": [
///     \"clientToServer\",
///     \"serverToClient\",
///     \"both\"
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MessageDirection {
    #[serde(rename = "clientToServer")]
    ClientToServer,
    #[serde(rename = "serverToClient")]
    ServerToClient,
    #[serde(rename = "both")]
    Both,
}
impl From<&MessageDirection> for MessageDirection {
    fn from(value: &MessageDirection) -> Self {
        value.clone()
    }
}
impl ToString for MessageDirection {
    fn to_string(&self) -> String {
        match *self {
            Self::ClientToServer => "clientToServer".to_string(),
            Self::ServerToClient => "serverToClient".to_string(),
            Self::Both => "both".to_string(),
        }
    }
}
impl std::str::FromStr for MessageDirection {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "clientToServer" => Ok(Self::ClientToServer),
            "serverToClient" => Ok(Self::ServerToClient),
            "both" => Ok(Self::Both),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for MessageDirection {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MessageDirection {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MessageDirection {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
/// MetaData
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"type\": \"object\",
///   \"required\": [
///     \"version\"
///   ],
///   \"properties\": {
///     \"version\": {
///       \"description\": \"The protocol version.\",
///       \"type\": \"string\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaData {
    /// The protocol version.
    pub version: String,
}
impl From<&MetaData> for MetaData {
    fn from(value: &MetaData) -> Self {
        value.clone()
    }
}
/// The actual meta model.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"The actual meta model.\",
///   \"type\": \"object\",
///   \"required\": [
///     \"enumerations\",
///     \"metaData\",
///     \"notifications\",
///     \"requests\",
///     \"structures\",
///     \"typeAliases\"
///   ],
///   \"properties\": {
///     \"enumerations\": {
///       \"description\": \"The enumerations.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Enumeration\"
///       }
///     },
///     \"metaData\": {
///       \"description\": \"Additional meta data.\",
///       \"$ref\": \"#/definitions/MetaData\"
///     },
///     \"notifications\": {
///       \"description\": \"The notifications.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Notification\"
///       }
///     },
///     \"requests\": {
///       \"description\": \"The requests.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Request\"
///       }
///     },
///     \"structures\": {
///       \"description\": \"The structures.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Structure\"
///       }
///     },
///     \"typeAliases\": {
///       \"description\": \"The type aliases.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/TypeAlias\"
///       }
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct MetaModel {
    /// The enumerations.
    pub enumerations: Vec<Enumeration>,
    /// Additional meta data.
    #[serde(rename = "metaData")]
    pub meta_data: MetaData,
    /// The notifications.
    pub notifications: Vec<Notification>,
    /// The requests.
    pub requests: Vec<Request>,
    /// The structures.
    pub structures: Vec<Structure>,
    /// The type aliases.
    #[serde(rename = "typeAliases")]
    pub type_aliases: Vec<TypeAlias>,
}
impl From<&MetaModel> for MetaModel {
    fn from(value: &MetaModel) -> Self {
        value.clone()
    }
}
/// Represents a LSP notification
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a LSP notification\",
///   \"type\": \"object\",
///   \"required\": [
///     \"messageDirection\",
///     \"method\"
///   ],
///   \"properties\": {
///     \"deprecated\": {
///       \"description\": \"Whether the notification is deprecated or not. If deprecated the property contains the deprecation message.\",
///       \"type\": \"string\"
///     },
///     \"documentation\": {
///       \"description\": \"An optional documentation;\",
///       \"type\": \"string\"
///     },
///     \"messageDirection\": {
///       \"description\": \"The direction in which this notification is sent in the protocol.\",
///       \"$ref\": \"#/definitions/MessageDirection\"
///     },
///     \"method\": {
///       \"description\": \"The request's method name.\",
///       \"type\": \"string\"
///     },
///     \"params\": {
///       \"description\": \"The parameter type(s) if any.\",
///       \"anyOf\": [
///         {
///           \"$ref\": \"#/definitions/Type\"
///         },
///         {
///           \"type\": \"array\",
///           \"items\": {
///             \"$ref\": \"#/definitions/Type\"
///           }
///         }
///       ]
///     },
///     \"proposed\": {
///       \"description\": \"Whether this is a proposed notification. If omitted the notification is final.\",
///       \"type\": \"boolean\"
///     },
///     \"registrationMethod\": {
///       \"description\": \"Optional a dynamic registration method if it different from the request's method.\",
///       \"type\": \"string\"
///     },
///     \"registrationOptions\": {
///       \"description\": \"Optional registration options if the notification supports dynamic registration.\",
///       \"$ref\": \"#/definitions/Type\"
///     },
///     \"since\": {
///       \"description\": \"Since when (release number) this notification is available. Is undefined if not known.\",
///       \"type\": \"string\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Notification {
    /// Whether the notification is deprecated or not. If deprecated the property contains the deprecation message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<String>,
    /// An optional documentation;
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
    /// The direction in which this notification is sent in the protocol.
    #[serde(rename = "messageDirection")]
    pub message_direction: MessageDirection,
    /// The request's method name.
    pub method: String,
    /// The parameter type(s) if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<NotificationParams>,
    /// Whether this is a proposed notification. If omitted the notification is final.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proposed: Option<bool>,
    /// Optional a dynamic registration method if it different from the request's method.
    #[serde(
        rename = "registrationMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub registration_method: Option<String>,
    /// Optional registration options if the notification supports dynamic registration.
    #[serde(
        rename = "registrationOptions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub registration_options: Option<Type>,
    /// Since when (release number) this notification is available. Is undefined if not known.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
}
impl From<&Notification> for Notification {
    fn from(value: &Notification) -> Self {
        value.clone()
    }
}
/// The parameter type(s) if any.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"The parameter type(s) if any.\",
///   \"anyOf\": [
///     {
///       \"$ref\": \"#/definitions/Type\"
///     },
///     {
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Type\"
///       }
///     }
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NotificationParams {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<Type>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<Vec<Type>>,
}
impl From<&NotificationParams> for NotificationParams {
    fn from(value: &NotificationParams) -> Self {
        value.clone()
    }
}
/// Represents an `or` type (e.g. `Location | LocationLink`).
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents an `or` type (e.g. `Location | LocationLink`).\",
///   \"type\": \"object\",
///   \"required\": [
///     \"items\",
///     \"kind\"
///   ],
///   \"properties\": {
///     \"items\": {
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Type\"
///       }
///     },
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"or\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OrType {
    pub items: Vec<Type>,
    pub kind: String,
}
impl From<&OrType> for OrType {
    fn from(value: &OrType) -> Self {
        value.clone()
    }
}
/// Represents an object property.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents an object property.\",
///   \"type\": \"object\",
///   \"required\": [
///     \"name\",
///     \"type\"
///   ],
///   \"properties\": {
///     \"deprecated\": {
///       \"description\": \"Whether the property is deprecated or not. If deprecated the property contains the deprecation message.\",
///       \"type\": \"string\"
///     },
///     \"documentation\": {
///       \"description\": \"An optional documentation.\",
///       \"type\": \"string\"
///     },
///     \"name\": {
///       \"description\": \"The property name;\",
///       \"type\": \"string\"
///     },
///     \"optional\": {
///       \"description\": \"Whether the property is optional. If omitted, the property is mandatory.\",
///       \"type\": \"boolean\"
///     },
///     \"proposed\": {
///       \"description\": \"Whether this is a proposed property. If omitted, the structure is final.\",
///       \"type\": \"boolean\"
///     },
///     \"since\": {
///       \"description\": \"Since when (release number) this property is available. Is undefined if not known.\",
///       \"type\": \"string\"
///     },
///     \"type\": {
///       \"description\": \"The type of the property\",
///       \"$ref\": \"#/definitions/Type\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Property {
    /// Whether the property is deprecated or not. If deprecated the property contains the deprecation message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<String>,
    /// An optional documentation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
    /// The property name;
    pub name: String,
    /// Whether the property is optional. If omitted, the property is mandatory.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
    /// Whether this is a proposed property. If omitted, the structure is final.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proposed: Option<bool>,
    /// Since when (release number) this property is available. Is undefined if not known.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
    /// The type of the property
    #[serde(rename = "type")]
    pub type_: Type,
}
impl From<&Property> for Property {
    fn from(value: &Property) -> Self {
        value.clone()
    }
}
/// Represents a reference to another type (e.g. `TextDocument`). This is either a `Structure`, a `Enumeration` or a `TypeAlias` in the same meta model.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a reference to another type (e.g. `TextDocument`). This is either a `Structure`, a `Enumeration` or a `TypeAlias` in the same meta model.\",
///   \"type\": \"object\",
///   \"required\": [
///     \"kind\",
///     \"name\"
///   ],
///   \"properties\": {
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"reference\"
///     },
///     \"name\": {
///       \"type\": \"string\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ReferenceType {
    pub kind: String,
    pub name: String,
}
impl From<&ReferenceType> for ReferenceType {
    fn from(value: &ReferenceType) -> Self {
        value.clone()
    }
}
/// Represents a LSP request
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a LSP request\",
///   \"type\": \"object\",
///   \"required\": [
///     \"messageDirection\",
///     \"method\",
///     \"result\"
///   ],
///   \"properties\": {
///     \"deprecated\": {
///       \"description\": \"Whether the request is deprecated or not. If deprecated the property contains the deprecation message.\",
///       \"type\": \"string\"
///     },
///     \"documentation\": {
///       \"description\": \"An optional documentation;\",
///       \"type\": \"string\"
///     },
///     \"errorData\": {
///       \"description\": \"An optional error data type.\",
///       \"$ref\": \"#/definitions/Type\"
///     },
///     \"messageDirection\": {
///       \"description\": \"The direction in which this request is sent in the protocol.\",
///       \"$ref\": \"#/definitions/MessageDirection\"
///     },
///     \"method\": {
///       \"description\": \"The request's method name.\",
///       \"type\": \"string\"
///     },
///     \"params\": {
///       \"description\": \"The parameter type(s) if any.\",
///       \"anyOf\": [
///         {
///           \"$ref\": \"#/definitions/Type\"
///         },
///         {
///           \"type\": \"array\",
///           \"items\": {
///             \"$ref\": \"#/definitions/Type\"
///           }
///         }
///       ]
///     },
///     \"partialResult\": {
///       \"description\": \"Optional partial result type if the request supports partial result reporting.\",
///       \"$ref\": \"#/definitions/Type\"
///     },
///     \"proposed\": {
///       \"description\": \"Whether this is a proposed feature. If omitted the feature is final.\",
///       \"type\": \"boolean\"
///     },
///     \"registrationMethod\": {
///       \"description\": \"Optional a dynamic registration method if it different from the request's method.\",
///       \"type\": \"string\"
///     },
///     \"registrationOptions\": {
///       \"description\": \"Optional registration options if the request supports dynamic registration.\",
///       \"$ref\": \"#/definitions/Type\"
///     },
///     \"result\": {
///       \"description\": \"The result type.\",
///       \"$ref\": \"#/definitions/Type\"
///     },
///     \"since\": {
///       \"description\": \"Since when (release number) this request is available. Is undefined if not known.\",
///       \"type\": \"string\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Request {
    /// Whether the request is deprecated or not. If deprecated the property contains the deprecation message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<String>,
    /// An optional documentation;
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
    /// An optional error data type.
    #[serde(rename = "errorData", default, skip_serializing_if = "Option::is_none")]
    pub error_data: Option<Type>,
    /// The direction in which this request is sent in the protocol.
    #[serde(rename = "messageDirection")]
    pub message_direction: MessageDirection,
    /// The request's method name.
    pub method: String,
    /// The parameter type(s) if any.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<RequestParams>,
    /// Optional partial result type if the request supports partial result reporting.
    #[serde(
        rename = "partialResult",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub partial_result: Option<Type>,
    /// Whether this is a proposed feature. If omitted the feature is final.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proposed: Option<bool>,
    /// Optional a dynamic registration method if it different from the request's method.
    #[serde(
        rename = "registrationMethod",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub registration_method: Option<String>,
    /// Optional registration options if the request supports dynamic registration.
    #[serde(
        rename = "registrationOptions",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub registration_options: Option<Type>,
    /// The result type.
    pub result: Type,
    /// Since when (release number) this request is available. Is undefined if not known.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
}
impl From<&Request> for Request {
    fn from(value: &Request) -> Self {
        value.clone()
    }
}
/// The parameter type(s) if any.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"The parameter type(s) if any.\",
///   \"anyOf\": [
///     {
///       \"$ref\": \"#/definitions/Type\"
///     },
///     {
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Type\"
///       }
///     }
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RequestParams {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<Type>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<Vec<Type>>,
}
impl From<&RequestParams> for RequestParams {
    fn from(value: &RequestParams) -> Self {
        value.clone()
    }
}
/// Represents a string literal type (e.g. `kind: 'rename'`).
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a string literal type (e.g. `kind: 'rename'`).\",
///   \"type\": \"object\",
///   \"required\": [
///     \"kind\",
///     \"value\"
///   ],
///   \"properties\": {
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"stringLiteral\"
///     },
///     \"value\": {
///       \"type\": \"string\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StringLiteralType {
    pub kind: String,
    pub value: String,
}
impl From<&StringLiteralType> for StringLiteralType {
    fn from(value: &StringLiteralType) -> Self {
        value.clone()
    }
}
/// Defines the structure of an object literal.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Defines the structure of an object literal.\",
///   \"type\": \"object\",
///   \"required\": [
///     \"name\",
///     \"properties\"
///   ],
///   \"properties\": {
///     \"deprecated\": {
///       \"description\": \"Whether the structure is deprecated or not. If deprecated the property contains the deprecation message.\",
///       \"type\": \"string\"
///     },
///     \"documentation\": {
///       \"description\": \"An optional documentation;\",
///       \"type\": \"string\"
///     },
///     \"extends\": {
///       \"description\": \"Structures extended from. This structures form a polymorphic type hierarchy.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Type\"
///       }
///     },
///     \"mixins\": {
///       \"description\": \"Structures to mix in. The properties of these structures are `copied` into this structure. Mixins don't form a polymorphic type hierarchy in LSP.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Type\"
///       }
///     },
///     \"name\": {
///       \"description\": \"The name of the structure.\",
///       \"type\": \"string\"
///     },
///     \"properties\": {
///       \"description\": \"The properties.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Property\"
///       }
///     },
///     \"proposed\": {
///       \"description\": \"Whether this is a proposed structure. If omitted, the structure is final.\",
///       \"type\": \"boolean\"
///     },
///     \"since\": {
///       \"description\": \"Since when (release number) this structure is available. Is undefined if not known.\",
///       \"type\": \"string\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Structure {
    /// Whether the structure is deprecated or not. If deprecated the property contains the deprecation message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<String>,
    /// An optional documentation;
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
    /// Structures extended from. This structures form a polymorphic type hierarchy.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub extends: Vec<Type>,
    /// Structures to mix in. The properties of these structures are `copied` into this structure. Mixins don't form a polymorphic type hierarchy in LSP.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub mixins: Vec<Type>,
    /// The name of the structure.
    pub name: String,
    /// The properties.
    pub properties: Vec<Property>,
    /// Whether this is a proposed structure. If omitted, the structure is final.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proposed: Option<bool>,
    /// Since when (release number) this structure is available. Is undefined if not known.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
}
impl From<&Structure> for Structure {
    fn from(value: &Structure) -> Self {
        value.clone()
    }
}
/// Defines an unnamed structure of an object literal.
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Defines an unnamed structure of an object literal.\",
///   \"type\": \"object\",
///   \"required\": [
///     \"properties\"
///   ],
///   \"properties\": {
///     \"deprecated\": {
///       \"description\": \"Whether the literal is deprecated or not. If deprecated the property contains the deprecation message.\",
///       \"type\": \"string\"
///     },
///     \"documentation\": {
///       \"description\": \"An optional documentation.\",
///       \"type\": \"string\"
///     },
///     \"properties\": {
///       \"description\": \"The properties.\",
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Property\"
///       }
///     },
///     \"proposed\": {
///       \"description\": \"Whether this is a proposed structure. If omitted, the structure is final.\",
///       \"type\": \"boolean\"
///     },
///     \"since\": {
///       \"description\": \"Since when (release number) this structure is available. Is undefined if not known.\",
///       \"type\": \"string\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StructureLiteral {
    /// Whether the literal is deprecated or not. If deprecated the property contains the deprecation message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<String>,
    /// An optional documentation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
    /// The properties.
    pub properties: Vec<Property>,
    /// Whether this is a proposed structure. If omitted, the structure is final.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proposed: Option<bool>,
    /// Since when (release number) this structure is available. Is undefined if not known.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
}
impl From<&StructureLiteral> for StructureLiteral {
    fn from(value: &StructureLiteral) -> Self {
        value.clone()
    }
}
/// Represents a literal structure (e.g. `property: { start: uinteger; end: uinteger; }`).
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a literal structure (e.g. `property: { start: uinteger; end: uinteger; }`).\",
///   \"type\": \"object\",
///   \"required\": [
///     \"kind\",
///     \"value\"
///   ],
///   \"properties\": {
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"literal\"
///     },
///     \"value\": {
///       \"$ref\": \"#/definitions/StructureLiteral\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StructureLiteralType {
    pub kind: String,
    pub value: StructureLiteral,
}
impl From<&StructureLiteralType> for StructureLiteralType {
    fn from(value: &StructureLiteralType) -> Self {
        value.clone()
    }
}
/// Represents a `tuple` type (e.g. `[integer, integer]`).
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Represents a `tuple` type (e.g. `[integer, integer]`).\",
///   \"type\": \"object\",
///   \"required\": [
///     \"items\",
///     \"kind\"
///   ],
///   \"properties\": {
///     \"items\": {
///       \"type\": \"array\",
///       \"items\": {
///         \"$ref\": \"#/definitions/Type\"
///       }
///     },
///     \"kind\": {
///       \"type\": \"string\",
///       \"const\": \"tuple\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TupleType {
    pub items: Vec<Type>,
    pub kind: String,
}
impl From<&TupleType> for TupleType {
    fn from(value: &TupleType) -> Self {
        value.clone()
    }
}
/// Type
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"anyOf\": [
///     {
///       \"$ref\": \"#/definitions/BaseType\"
///     },
///     {
///       \"$ref\": \"#/definitions/ReferenceType\"
///     },
///     {
///       \"$ref\": \"#/definitions/ArrayType\"
///     },
///     {
///       \"$ref\": \"#/definitions/MapType\"
///     },
///     {
///       \"$ref\": \"#/definitions/AndType\"
///     },
///     {
///       \"$ref\": \"#/definitions/OrType\"
///     },
///     {
///       \"$ref\": \"#/definitions/TupleType\"
///     },
///     {
///       \"$ref\": \"#/definitions/StructureLiteralType\"
///     },
///     {
///       \"$ref\": \"#/definitions/StringLiteralType\"
///     },
///     {
///       \"$ref\": \"#/definitions/IntegerLiteralType\"
///     },
///     {
///       \"$ref\": \"#/definitions/BooleanLiteralType\"
///     }
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Type {
    BaseType(BaseType),
    ReferenceType(ReferenceType),
    ArrayType(Box<ArrayType>),
    MapType(MapType),
    AndType(AndType),
    OrType(OrType),
    TupleType(TupleType),
    StructureLiteralType(StructureLiteralType),
    StringLiteralType(StringLiteralType),
    IntegerLiteralType(IntegerLiteralType),
    BooleanLiteralType(BooleanLiteralType),
}
impl From<&Type> for Type {
    fn from(value: &Type) -> Self {
        value.clone()
    }
}
impl From<BaseType> for Type {
    fn from(value: BaseType) -> Self {
        Self::BaseType(value)
    }
}
impl From<ReferenceType> for Type {
    fn from(value: ReferenceType) -> Self {
        Self::ReferenceType(value)
    }
}
impl From<Box<ArrayType>> for Type {
    fn from(value: Box<ArrayType>) -> Self {
        Self::ArrayType(value)
    }
}
impl From<MapType> for Type {
    fn from(value: MapType) -> Self {
        Self::MapType(value)
    }
}
impl From<AndType> for Type {
    fn from(value: AndType) -> Self {
        Self::AndType(value)
    }
}
impl From<OrType> for Type {
    fn from(value: OrType) -> Self {
        Self::OrType(value)
    }
}
impl From<TupleType> for Type {
    fn from(value: TupleType) -> Self {
        Self::TupleType(value)
    }
}
impl From<StructureLiteralType> for Type {
    fn from(value: StructureLiteralType) -> Self {
        Self::StructureLiteralType(value)
    }
}
impl From<StringLiteralType> for Type {
    fn from(value: StringLiteralType) -> Self {
        Self::StringLiteralType(value)
    }
}
impl From<IntegerLiteralType> for Type {
    fn from(value: IntegerLiteralType) -> Self {
        Self::IntegerLiteralType(value)
    }
}
impl From<BooleanLiteralType> for Type {
    fn from(value: BooleanLiteralType) -> Self {
        Self::BooleanLiteralType(value)
    }
}
/// Defines a type alias. (e.g. `type Definition = Location | LocationLink`)
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"description\": \"Defines a type alias. (e.g. `type Definition = Location | LocationLink`)\",
///   \"type\": \"object\",
///   \"required\": [
///     \"name\",
///     \"type\"
///   ],
///   \"properties\": {
///     \"deprecated\": {
///       \"description\": \"Whether the type alias is deprecated or not. If deprecated the property contains the deprecation message.\",
///       \"type\": \"string\"
///     },
///     \"documentation\": {
///       \"description\": \"An optional documentation.\",
///       \"type\": \"string\"
///     },
///     \"name\": {
///       \"description\": \"The name of the type alias.\",
///       \"type\": \"string\"
///     },
///     \"proposed\": {
///       \"description\": \"Whether this is a proposed type alias. If omitted, the type alias is final.\",
///       \"type\": \"boolean\"
///     },
///     \"since\": {
///       \"description\": \"Since when (release number) this structure is available. Is undefined if not known.\",
///       \"type\": \"string\"
///     },
///     \"type\": {
///       \"description\": \"The aliased type.\",
///       \"$ref\": \"#/definitions/Type\"
///     }
///   },
///   \"additionalProperties\": false
/// }
///  ```
///  </details>
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TypeAlias {
    /// Whether the type alias is deprecated or not. If deprecated the property contains the deprecation message.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<String>,
    /// An optional documentation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub documentation: Option<String>,
    /// The name of the type alias.
    pub name: String,
    /// Whether this is a proposed type alias. If omitted, the type alias is final.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub proposed: Option<bool>,
    /// Since when (release number) this structure is available. Is undefined if not known.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub since: Option<String>,
    /// The aliased type.
    #[serde(rename = "type")]
    pub type_: Type,
}
impl From<&TypeAlias> for TypeAlias {
    fn from(value: &TypeAlias) -> Self {
        value.clone()
    }
}
/// TypeKind
///
///  <details><summary>JSON schema</summary>
///
///  ```json
/// {
///   \"type\": \"string\",
///   \"enum\": [
///     \"base\",
///     \"reference\",
///     \"array\",
///     \"map\",
///     \"and\",
///     \"or\",
///     \"tuple\",
///     \"literal\",
///     \"stringLiteral\",
///     \"integerLiteral\",
///     \"booleanLiteral\"
///   ]
/// }
///  ```
///  </details>
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TypeKind {
    #[serde(rename = "base")]
    Base,
    #[serde(rename = "reference")]
    Reference,
    #[serde(rename = "array")]
    Array,
    #[serde(rename = "map")]
    Map,
    #[serde(rename = "and")]
    And,
    #[serde(rename = "or")]
    Or,
    #[serde(rename = "tuple")]
    Tuple,
    #[serde(rename = "literal")]
    Literal,
    #[serde(rename = "stringLiteral")]
    StringLiteral,
    #[serde(rename = "integerLiteral")]
    IntegerLiteral,
    #[serde(rename = "booleanLiteral")]
    BooleanLiteral,
}
impl From<&TypeKind> for TypeKind {
    fn from(value: &TypeKind) -> Self {
        value.clone()
    }
}
impl ToString for TypeKind {
    fn to_string(&self) -> String {
        match *self {
            Self::Base => "base".to_string(),
            Self::Reference => "reference".to_string(),
            Self::Array => "array".to_string(),
            Self::Map => "map".to_string(),
            Self::And => "and".to_string(),
            Self::Or => "or".to_string(),
            Self::Tuple => "tuple".to_string(),
            Self::Literal => "literal".to_string(),
            Self::StringLiteral => "stringLiteral".to_string(),
            Self::IntegerLiteral => "integerLiteral".to_string(),
            Self::BooleanLiteral => "booleanLiteral".to_string(),
        }
    }
}
impl std::str::FromStr for TypeKind {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "base" => Ok(Self::Base),
            "reference" => Ok(Self::Reference),
            "array" => Ok(Self::Array),
            "map" => Ok(Self::Map),
            "and" => Ok(Self::And),
            "or" => Ok(Self::Or),
            "tuple" => Ok(Self::Tuple),
            "literal" => Ok(Self::Literal),
            "stringLiteral" => Ok(Self::StringLiteral),
            "integerLiteral" => Ok(Self::IntegerLiteral),
            "booleanLiteral" => Ok(Self::BooleanLiteral),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TypeKind {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TypeKind {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TypeKind {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
