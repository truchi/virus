// 🚨 This file is generated by `cargo xtask-lsp`

use super::*;

use super::requests::*;
fn missing_parameters() -> std::io::Error {
    std::io::Error::new(std::io::ErrorKind::InvalidData, "Missing parameters")
}
fn missing_result() -> std::io::Error {
    std::io::Error::new(std::io::ErrorKind::InvalidData, "Missing result")
}
fn unknown_method() -> std::io::Error {
    std::io::Error::new(std::io::ErrorKind::InvalidData, "Unknown method")
}
fn deserialize_error<T: DeserializeOwned>(error: Error<Value>) -> std::io::Result<Error<T>> {
    Ok(Error {
        code: error.code,
        message: error.message,
        data: error
            .data
            .map(|data| serde_json::from_value(data))
            .transpose()?,
    })
}
fn empty_error(error: Error<Value>) -> Error<()> {
    debug_assert!(error.data.is_none());
    Error {
        code: error.code,
        message: error.message,
        data: None,
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                       ServerNotification                                       //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// Parameters of a server-to-client notification.
#[derive(Clone, PartialEq, Debug)]
pub enum ServerNotification {
    /// @see [`CancelRequest`](super::notifications::CancelRequest).
    CancelRequest(super::structures::CancelParams),
    /// @see [`LogTrace`](super::notifications::LogTrace).
    LogTrace(super::structures::LogTraceParams),
    /// @see [`Progress`](super::notifications::Progress).
    Progress(super::structures::ProgressParams),
    /// @see [`TelemetryEvent`](super::notifications::TelemetryEvent).
    TelemetryEvent(super::type_aliases::LspAny),
    /// @see [`TextDocumentPublishDiagnostics`](super::notifications::TextDocumentPublishDiagnostics).
    TextDocumentPublishDiagnostics(super::structures::PublishDiagnosticsParams),
    /// @see [`WindowLogMessage`](super::notifications::WindowLogMessage).
    WindowLogMessage(super::structures::LogMessageParams),
    /// @see [`WindowShowMessage`](super::notifications::WindowShowMessage).
    WindowShowMessage(super::structures::ShowMessageParams),
}

impl ServerNotification {
    pub fn deserialize(notification: Notification<Value>) -> std::io::Result<Self> {
        Ok(match notification.method.as_ref() {
            "$/cancelRequest" => Self::CancelRequest(serde_json::from_value(
                notification.params.ok_or_else(missing_parameters)?,
            )?),
            "$/logTrace" => Self::LogTrace(serde_json::from_value(
                notification.params.ok_or_else(missing_parameters)?,
            )?),
            "$/progress" => Self::Progress(serde_json::from_value(
                notification.params.ok_or_else(missing_parameters)?,
            )?),
            "telemetry/event" => Self::TelemetryEvent(serde_json::from_value(
                notification.params.ok_or_else(missing_parameters)?,
            )?),
            "textDocument/publishDiagnostics" => Self::TextDocumentPublishDiagnostics(
                serde_json::from_value(notification.params.ok_or_else(missing_parameters)?)?,
            ),
            "window/logMessage" => Self::WindowLogMessage(serde_json::from_value(
                notification.params.ok_or_else(missing_parameters)?,
            )?),
            "window/showMessage" => Self::WindowShowMessage(serde_json::from_value(
                notification.params.ok_or_else(missing_parameters)?,
            )?),
            _ => return Err(unknown_method()),
        })
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                         ServerRequest                                          //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// Parameters of a server-to-client request.
#[derive(Clone, PartialEq, Debug)]
pub enum ServerRequest {
    /// @see [`ClientRegisterCapability`](super::requests::ClientRegisterCapability).
    ClientRegisterCapability(Id, super::structures::RegistrationParams),
    /// @see [`ClientUnregisterCapability`](super::requests::ClientUnregisterCapability).
    ClientUnregisterCapability(Id, super::structures::UnregistrationParams),
    /// @see [`WindowShowDocument`](super::requests::WindowShowDocument).
    WindowShowDocument(Id, super::structures::ShowDocumentParams),
    /// @see [`WindowShowMessageRequest`](super::requests::WindowShowMessageRequest).
    WindowShowMessageRequest(Id, super::structures::ShowMessageRequestParams),
    /// @see [`WindowWorkDoneProgressCreate`](super::requests::WindowWorkDoneProgressCreate).
    WindowWorkDoneProgressCreate(Id, super::structures::WorkDoneProgressCreateParams),
    /// @see [`WorkspaceApplyEdit`](super::requests::WorkspaceApplyEdit).
    WorkspaceApplyEdit(Id, super::structures::ApplyWorkspaceEditParams),
    /// @see [`WorkspaceCodeLensRefresh`](super::requests::WorkspaceCodeLensRefresh).
    WorkspaceCodeLensRefresh(Id),
    /// @see [`WorkspaceConfiguration`](super::requests::WorkspaceConfiguration).
    WorkspaceConfiguration(Id, super::structures::ConfigurationParams),
    /// @see [`WorkspaceDiagnosticRefresh`](super::requests::WorkspaceDiagnosticRefresh).
    WorkspaceDiagnosticRefresh(Id),
    /// @see [`WorkspaceInlayHintRefresh`](super::requests::WorkspaceInlayHintRefresh).
    WorkspaceInlayHintRefresh(Id),
    /// @see [`WorkspaceInlineValueRefresh`](super::requests::WorkspaceInlineValueRefresh).
    WorkspaceInlineValueRefresh(Id),
    /// @see [`WorkspaceSemanticTokensRefresh`](super::requests::WorkspaceSemanticTokensRefresh).
    WorkspaceSemanticTokensRefresh(Id),
    /// @see [`WorkspaceWorkspaceFolders`](super::requests::WorkspaceWorkspaceFolders).
    WorkspaceWorkspaceFolders(Id),
}

impl ServerRequest {
    pub fn deserialize(request: Request<Value>) -> std::io::Result<Self> {
        Ok(match request.method.as_ref() {
            "client/registerCapability" => Self::ClientRegisterCapability(
                request.id,
                serde_json::from_value(request.params.ok_or_else(missing_parameters)?)?,
            ),
            "client/unregisterCapability" => Self::ClientUnregisterCapability(
                request.id,
                serde_json::from_value(request.params.ok_or_else(missing_parameters)?)?,
            ),
            "window/showDocument" => Self::WindowShowDocument(
                request.id,
                serde_json::from_value(request.params.ok_or_else(missing_parameters)?)?,
            ),
            "window/showMessageRequest" => Self::WindowShowMessageRequest(
                request.id,
                serde_json::from_value(request.params.ok_or_else(missing_parameters)?)?,
            ),
            "window/workDoneProgress/create" => Self::WindowWorkDoneProgressCreate(
                request.id,
                serde_json::from_value(request.params.ok_or_else(missing_parameters)?)?,
            ),
            "workspace/applyEdit" => Self::WorkspaceApplyEdit(
                request.id,
                serde_json::from_value(request.params.ok_or_else(missing_parameters)?)?,
            ),
            "workspace/codeLens/refresh" => {
                debug_assert!(request.params.is_none());
                Self::WorkspaceCodeLensRefresh(request.id)
            }
            "workspace/configuration" => Self::WorkspaceConfiguration(
                request.id,
                serde_json::from_value(request.params.ok_or_else(missing_parameters)?)?,
            ),
            "workspace/diagnostic/refresh" => {
                debug_assert!(request.params.is_none());
                Self::WorkspaceDiagnosticRefresh(request.id)
            }
            "workspace/inlayHint/refresh" => {
                debug_assert!(request.params.is_none());
                Self::WorkspaceInlayHintRefresh(request.id)
            }
            "workspace/inlineValue/refresh" => {
                debug_assert!(request.params.is_none());
                Self::WorkspaceInlineValueRefresh(request.id)
            }
            "workspace/semanticTokens/refresh" => {
                debug_assert!(request.params.is_none());
                Self::WorkspaceSemanticTokensRefresh(request.id)
            }
            "workspace/workspaceFolders" => {
                debug_assert!(request.params.is_none());
                Self::WorkspaceWorkspaceFolders(request.id)
            }
            _ => return Err(unknown_method()),
        })
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                         ServerResponse                                         //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// Result or error of a client-to-server request.
#[derive(Clone, PartialEq, Debug)]
pub enum ServerResponse {
    /// @see [`CallHierarchyIncomingCalls`](super::requests::CallHierarchyIncomingCalls).
    CallHierarchyIncomingCalls(
        Option<Id>,
        Result<CallHierarchyIncomingCallsResult, Error<()>>,
    ),
    /// @see [`CallHierarchyOutgoingCalls`](super::requests::CallHierarchyOutgoingCalls).
    CallHierarchyOutgoingCalls(
        Option<Id>,
        Result<CallHierarchyOutgoingCallsResult, Error<()>>,
    ),
    /// @see [`CodeActionResolve`](super::requests::CodeActionResolve).
    CodeActionResolve(Option<Id>, Result<super::structures::CodeAction, Error<()>>),
    /// @see [`CodeLensResolve`](super::requests::CodeLensResolve).
    CodeLensResolve(Option<Id>, Result<super::structures::CodeLens, Error<()>>),
    /// @see [`CompletionItemResolve`](super::requests::CompletionItemResolve).
    CompletionItemResolve(
        Option<Id>,
        Result<super::structures::CompletionItem, Error<()>>,
    ),
    /// @see [`DocumentLinkResolve`](super::requests::DocumentLinkResolve).
    DocumentLinkResolve(
        Option<Id>,
        Result<super::structures::DocumentLink, Error<()>>,
    ),
    /// @see [`Initialize`](super::requests::Initialize).
    Initialize(
        Option<Id>,
        Result<super::structures::InitializeResult, Error<super::structures::InitializeError>>,
    ),
    /// @see [`InlayHintResolve`](super::requests::InlayHintResolve).
    InlayHintResolve(Option<Id>, Result<super::structures::InlayHint, Error<()>>),
    /// @see [`Shutdown`](super::requests::Shutdown).
    Shutdown(Option<Id>, Result<Null, Error<()>>),
    /// @see [`TextDocumentCodeAction`](super::requests::TextDocumentCodeAction).
    TextDocumentCodeAction(Option<Id>, Result<TextDocumentCodeActionResult, Error<()>>),
    /// @see [`TextDocumentCodeLens`](super::requests::TextDocumentCodeLens).
    TextDocumentCodeLens(Option<Id>, Result<TextDocumentCodeLensResult, Error<()>>),
    /// @see [`TextDocumentColorPresentation`](super::requests::TextDocumentColorPresentation).
    TextDocumentColorPresentation(
        Option<Id>,
        Result<Vec<super::structures::ColorPresentation>, Error<()>>,
    ),
    /// @see [`TextDocumentCompletion`](super::requests::TextDocumentCompletion).
    TextDocumentCompletion(Option<Id>, Result<TextDocumentCompletionResult, Error<()>>),
    /// @see [`TextDocumentDeclaration`](super::requests::TextDocumentDeclaration).
    TextDocumentDeclaration(Option<Id>, Result<TextDocumentDeclarationResult, Error<()>>),
    /// @see [`TextDocumentDefinition`](super::requests::TextDocumentDefinition).
    TextDocumentDefinition(Option<Id>, Result<TextDocumentDefinitionResult, Error<()>>),
    /// @see [`TextDocumentDiagnostic`](super::requests::TextDocumentDiagnostic).
    TextDocumentDiagnostic(
        Option<Id>,
        Result<
            super::type_aliases::DocumentDiagnosticReport,
            Error<super::structures::DiagnosticServerCancellationData>,
        >,
    ),
    /// @see [`TextDocumentDocumentColor`](super::requests::TextDocumentDocumentColor).
    TextDocumentDocumentColor(
        Option<Id>,
        Result<Vec<super::structures::ColorInformation>, Error<()>>,
    ),
    /// @see [`TextDocumentDocumentHighlight`](super::requests::TextDocumentDocumentHighlight).
    TextDocumentDocumentHighlight(
        Option<Id>,
        Result<TextDocumentDocumentHighlightResult, Error<()>>,
    ),
    /// @see [`TextDocumentDocumentLink`](super::requests::TextDocumentDocumentLink).
    TextDocumentDocumentLink(
        Option<Id>,
        Result<TextDocumentDocumentLinkResult, Error<()>>,
    ),
    /// @see [`TextDocumentDocumentSymbol`](super::requests::TextDocumentDocumentSymbol).
    TextDocumentDocumentSymbol(
        Option<Id>,
        Result<TextDocumentDocumentSymbolResult, Error<()>>,
    ),
    /// @see [`TextDocumentFoldingRange`](super::requests::TextDocumentFoldingRange).
    TextDocumentFoldingRange(
        Option<Id>,
        Result<TextDocumentFoldingRangeResult, Error<()>>,
    ),
    /// @see [`TextDocumentFormatting`](super::requests::TextDocumentFormatting).
    TextDocumentFormatting(Option<Id>, Result<TextDocumentFormattingResult, Error<()>>),
    /// @see [`TextDocumentHover`](super::requests::TextDocumentHover).
    TextDocumentHover(Option<Id>, Result<TextDocumentHoverResult, Error<()>>),
    /// @see [`TextDocumentImplementation`](super::requests::TextDocumentImplementation).
    TextDocumentImplementation(
        Option<Id>,
        Result<TextDocumentImplementationResult, Error<()>>,
    ),
    /// @see [`TextDocumentInlayHint`](super::requests::TextDocumentInlayHint).
    TextDocumentInlayHint(Option<Id>, Result<TextDocumentInlayHintResult, Error<()>>),
    /// @see [`TextDocumentInlineValue`](super::requests::TextDocumentInlineValue).
    TextDocumentInlineValue(Option<Id>, Result<TextDocumentInlineValueResult, Error<()>>),
    /// @see [`TextDocumentLinkedEditingRange`](super::requests::TextDocumentLinkedEditingRange).
    TextDocumentLinkedEditingRange(
        Option<Id>,
        Result<TextDocumentLinkedEditingRangeResult, Error<()>>,
    ),
    /// @see [`TextDocumentMoniker`](super::requests::TextDocumentMoniker).
    TextDocumentMoniker(Option<Id>, Result<TextDocumentMonikerResult, Error<()>>),
    /// @see [`TextDocumentOnTypeFormatting`](super::requests::TextDocumentOnTypeFormatting).
    TextDocumentOnTypeFormatting(
        Option<Id>,
        Result<TextDocumentOnTypeFormattingResult, Error<()>>,
    ),
    /// @see [`TextDocumentPrepareCallHierarchy`](super::requests::TextDocumentPrepareCallHierarchy).
    TextDocumentPrepareCallHierarchy(
        Option<Id>,
        Result<TextDocumentPrepareCallHierarchyResult, Error<()>>,
    ),
    /// @see [`TextDocumentPrepareRename`](super::requests::TextDocumentPrepareRename).
    TextDocumentPrepareRename(
        Option<Id>,
        Result<TextDocumentPrepareRenameResult, Error<()>>,
    ),
    /// @see [`TextDocumentPrepareTypeHierarchy`](super::requests::TextDocumentPrepareTypeHierarchy).
    TextDocumentPrepareTypeHierarchy(
        Option<Id>,
        Result<TextDocumentPrepareTypeHierarchyResult, Error<()>>,
    ),
    /// @see [`TextDocumentRangeFormatting`](super::requests::TextDocumentRangeFormatting).
    TextDocumentRangeFormatting(
        Option<Id>,
        Result<TextDocumentRangeFormattingResult, Error<()>>,
    ),
    /// @see [`TextDocumentReferences`](super::requests::TextDocumentReferences).
    TextDocumentReferences(Option<Id>, Result<TextDocumentReferencesResult, Error<()>>),
    /// @see [`TextDocumentRename`](super::requests::TextDocumentRename).
    TextDocumentRename(Option<Id>, Result<TextDocumentRenameResult, Error<()>>),
    /// @see [`TextDocumentSelectionRange`](super::requests::TextDocumentSelectionRange).
    TextDocumentSelectionRange(
        Option<Id>,
        Result<TextDocumentSelectionRangeResult, Error<()>>,
    ),
    /// @see [`TextDocumentSemanticTokensFull`](super::requests::TextDocumentSemanticTokensFull).
    TextDocumentSemanticTokensFull(
        Option<Id>,
        Result<TextDocumentSemanticTokensFullResult, Error<()>>,
    ),
    /// @see [`TextDocumentSemanticTokensFullDelta`](super::requests::TextDocumentSemanticTokensFullDelta).
    TextDocumentSemanticTokensFullDelta(
        Option<Id>,
        Result<TextDocumentSemanticTokensFullDeltaResult, Error<()>>,
    ),
    /// @see [`TextDocumentSemanticTokensRange`](super::requests::TextDocumentSemanticTokensRange).
    TextDocumentSemanticTokensRange(
        Option<Id>,
        Result<TextDocumentSemanticTokensRangeResult, Error<()>>,
    ),
    /// @see [`TextDocumentSignatureHelp`](super::requests::TextDocumentSignatureHelp).
    TextDocumentSignatureHelp(
        Option<Id>,
        Result<TextDocumentSignatureHelpResult, Error<()>>,
    ),
    /// @see [`TextDocumentTypeDefinition`](super::requests::TextDocumentTypeDefinition).
    TextDocumentTypeDefinition(
        Option<Id>,
        Result<TextDocumentTypeDefinitionResult, Error<()>>,
    ),
    /// @see [`TextDocumentWillSaveWaitUntil`](super::requests::TextDocumentWillSaveWaitUntil).
    TextDocumentWillSaveWaitUntil(
        Option<Id>,
        Result<TextDocumentWillSaveWaitUntilResult, Error<()>>,
    ),
    /// @see [`TypeHierarchySubtypes`](super::requests::TypeHierarchySubtypes).
    TypeHierarchySubtypes(Option<Id>, Result<TypeHierarchySubtypesResult, Error<()>>),
    /// @see [`TypeHierarchySupertypes`](super::requests::TypeHierarchySupertypes).
    TypeHierarchySupertypes(Option<Id>, Result<TypeHierarchySupertypesResult, Error<()>>),
    /// @see [`WorkspaceDiagnostic`](super::requests::WorkspaceDiagnostic).
    WorkspaceDiagnostic(
        Option<Id>,
        Result<
            super::structures::WorkspaceDiagnosticReport,
            Error<super::structures::DiagnosticServerCancellationData>,
        >,
    ),
    /// @see [`WorkspaceExecuteCommand`](super::requests::WorkspaceExecuteCommand).
    WorkspaceExecuteCommand(Option<Id>, Result<WorkspaceExecuteCommandResult, Error<()>>),
    /// @see [`WorkspaceSymbol`](super::requests::WorkspaceSymbol).
    WorkspaceSymbol(Option<Id>, Result<WorkspaceSymbolResult, Error<()>>),
    /// @see [`WorkspaceWillCreateFiles`](super::requests::WorkspaceWillCreateFiles).
    WorkspaceWillCreateFiles(
        Option<Id>,
        Result<WorkspaceWillCreateFilesResult, Error<()>>,
    ),
    /// @see [`WorkspaceWillDeleteFiles`](super::requests::WorkspaceWillDeleteFiles).
    WorkspaceWillDeleteFiles(
        Option<Id>,
        Result<WorkspaceWillDeleteFilesResult, Error<()>>,
    ),
    /// @see [`WorkspaceWillRenameFiles`](super::requests::WorkspaceWillRenameFiles).
    WorkspaceWillRenameFiles(
        Option<Id>,
        Result<WorkspaceWillRenameFilesResult, Error<()>>,
    ),
    /// @see [`WorkspaceSymbolResolve`](super::requests::WorkspaceSymbolResolve).
    WorkspaceSymbolResolve(
        Option<Id>,
        Result<super::structures::WorkspaceSymbol, Error<()>>,
    ),
}

impl ServerResponse {
    pub fn deserialize(response: Response<Value, Value>, method: &str) -> std::io::Result<Self> {
        Ok(match method {
            "callHierarchy/incomingCalls" => Self::CallHierarchyIncomingCalls(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(CallHierarchyIncomingCallsResult::Null(Null)))
                },
            ),
            "callHierarchy/outgoingCalls" => Self::CallHierarchyOutgoingCalls(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(CallHierarchyOutgoingCallsResult::Null(Null)))
                },
            ),
            "codeAction/resolve" => Self::CodeActionResolve(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "codeLens/resolve" => Self::CodeLensResolve(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "completionItem/resolve" => Self::CompletionItemResolve(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "documentLink/resolve" => Self::DocumentLinkResolve(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "initialize" => Self::Initialize(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(deserialize_error(error)?)
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "inlayHint/resolve" => Self::InlayHintResolve(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "shutdown" => Self::Shutdown(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(Null))
                },
            ),
            "textDocument/codeAction" => Self::TextDocumentCodeAction(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentCodeActionResult::Null(Null)))
                },
            ),
            "textDocument/codeLens" => Self::TextDocumentCodeLens(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentCodeLensResult::Null(Null)))
                },
            ),
            "textDocument/colorPresentation" => Self::TextDocumentColorPresentation(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "textDocument/completion" => Self::TextDocumentCompletion(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentCompletionResult::Null(Null)))
                },
            ),
            "textDocument/declaration" => Self::TextDocumentDeclaration(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentDeclarationResult::Null(Null)))
                },
            ),
            "textDocument/definition" => Self::TextDocumentDefinition(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentDefinitionResult::Null(Null)))
                },
            ),
            "textDocument/diagnostic" => Self::TextDocumentDiagnostic(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(deserialize_error(error)?)
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "textDocument/documentColor" => Self::TextDocumentDocumentColor(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "textDocument/documentHighlight" => Self::TextDocumentDocumentHighlight(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentDocumentHighlightResult::Null(Null)))
                },
            ),
            "textDocument/documentLink" => Self::TextDocumentDocumentLink(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentDocumentLinkResult::Null(Null)))
                },
            ),
            "textDocument/documentSymbol" => Self::TextDocumentDocumentSymbol(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentDocumentSymbolResult::Null(Null)))
                },
            ),
            "textDocument/foldingRange" => Self::TextDocumentFoldingRange(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentFoldingRangeResult::Null(Null)))
                },
            ),
            "textDocument/formatting" => Self::TextDocumentFormatting(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentFormattingResult::Null(Null)))
                },
            ),
            "textDocument/hover" => Self::TextDocumentHover(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentHoverResult::Null(Null)))
                },
            ),
            "textDocument/implementation" => Self::TextDocumentImplementation(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentImplementationResult::Null(Null)))
                },
            ),
            "textDocument/inlayHint" => Self::TextDocumentInlayHint(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentInlayHintResult::Null(Null)))
                },
            ),
            "textDocument/inlineValue" => Self::TextDocumentInlineValue(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentInlineValueResult::Null(Null)))
                },
            ),
            "textDocument/linkedEditingRange" => Self::TextDocumentLinkedEditingRange(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentLinkedEditingRangeResult::Null(Null)))
                },
            ),
            "textDocument/moniker" => Self::TextDocumentMoniker(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentMonikerResult::Null(Null)))
                },
            ),
            "textDocument/onTypeFormatting" => Self::TextDocumentOnTypeFormatting(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentOnTypeFormattingResult::Null(Null)))
                },
            ),
            "textDocument/prepareCallHierarchy" => Self::TextDocumentPrepareCallHierarchy(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentPrepareCallHierarchyResult::Null(Null)))
                },
            ),
            "textDocument/prepareRename" => Self::TextDocumentPrepareRename(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentPrepareRenameResult::Null(Null)))
                },
            ),
            "textDocument/prepareTypeHierarchy" => Self::TextDocumentPrepareTypeHierarchy(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentPrepareTypeHierarchyResult::Null(Null)))
                },
            ),
            "textDocument/rangeFormatting" => Self::TextDocumentRangeFormatting(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentRangeFormattingResult::Null(Null)))
                },
            ),
            "textDocument/references" => Self::TextDocumentReferences(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentReferencesResult::Null(Null)))
                },
            ),
            "textDocument/rename" => Self::TextDocumentRename(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentRenameResult::Null(Null)))
                },
            ),
            "textDocument/selectionRange" => Self::TextDocumentSelectionRange(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentSelectionRangeResult::Null(Null)))
                },
            ),
            "textDocument/semanticTokens/full" => Self::TextDocumentSemanticTokensFull(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentSemanticTokensFullResult::Null(Null)))
                },
            ),
            "textDocument/semanticTokens/full/delta" => Self::TextDocumentSemanticTokensFullDelta(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentSemanticTokensFullDeltaResult::Null(Null)))
                },
            ),
            "textDocument/semanticTokens/range" => Self::TextDocumentSemanticTokensRange(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentSemanticTokensRangeResult::Null(Null)))
                },
            ),
            "textDocument/signatureHelp" => Self::TextDocumentSignatureHelp(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentSignatureHelpResult::Null(Null)))
                },
            ),
            "textDocument/typeDefinition" => Self::TextDocumentTypeDefinition(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentTypeDefinitionResult::Null(Null)))
                },
            ),
            "textDocument/willSaveWaitUntil" => Self::TextDocumentWillSaveWaitUntil(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TextDocumentWillSaveWaitUntilResult::Null(Null)))
                },
            ),
            "typeHierarchy/subtypes" => Self::TypeHierarchySubtypes(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TypeHierarchySubtypesResult::Null(Null)))
                },
            ),
            "typeHierarchy/supertypes" => Self::TypeHierarchySupertypes(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(TypeHierarchySupertypesResult::Null(Null)))
                },
            ),
            "workspace/diagnostic" => Self::WorkspaceDiagnostic(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(deserialize_error(error)?)
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            "workspace/executeCommand" => Self::WorkspaceExecuteCommand(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(WorkspaceExecuteCommandResult::Null(Null)))
                },
            ),
            "workspace/symbol" => Self::WorkspaceSymbol(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(WorkspaceSymbolResult::Null(Null)))
                },
            ),
            "workspace/willCreateFiles" => Self::WorkspaceWillCreateFiles(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(WorkspaceWillCreateFilesResult::Null(Null)))
                },
            ),
            "workspace/willDeleteFiles" => Self::WorkspaceWillDeleteFiles(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(WorkspaceWillDeleteFilesResult::Null(Null)))
                },
            ),
            "workspace/willRenameFiles" => Self::WorkspaceWillRenameFiles(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(response
                        .result
                        .map(|result| serde_json::from_value(result))
                        .transpose()?
                        .unwrap_or(WorkspaceWillRenameFilesResult::Null(Null)))
                },
            ),
            "workspaceSymbol/resolve" => Self::WorkspaceSymbolResolve(
                response.id,
                if let Some(error) = response.error {
                    debug_assert!(response.result.is_none());
                    Err(empty_error(error))
                } else {
                    Ok(serde_json::from_value(
                        response.result.ok_or_else(missing_result)?,
                    )?)
                },
            ),
            _ => return Err(unknown_method()),
        })
    }
}
