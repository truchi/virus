// 🚨 This file is generated by `cargo xtask-lsp`

use super::*;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                       NotificationTrait                                        //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

fn missing_params() -> std::io::Error {
    std::io::Error::new(std::io::ErrorKind::InvalidData, "Missing params")
}

/// A trait for notifications.
pub trait NotificationTrait {
    const REGISTRATION_METHOD: Option<&'static str>;
    const METHOD: &'static str;
    type RegistrationOptions: 'static + Serialize + DeserializeOwned + Send + Sync;
    type Params: 'static + Serialize + DeserializeOwned + Send + Sync;
    fn params(params: Self::Params) -> Option<Self::Params>;
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params>;
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                         CancelRequest                                          //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ ⬅️
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#cancelRequest (Documentation)
pub enum CancelRequest {}

impl NotificationTrait for CancelRequest {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "$/cancelRequest";
    type RegistrationOptions = ();
    type Params = super::structures::CancelParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "$/cancelRequest");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                            LogTrace                                            //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ⬅️
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#logTrace (Documentation)
pub enum LogTrace {}

impl NotificationTrait for LogTrace {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "$/logTrace";
    type RegistrationOptions = ();
    type Params = super::structures::LogTraceParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "$/logTrace");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                            Progress                                            //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ ⬅️
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#progress (Documentation)
pub enum Progress {}

impl NotificationTrait for Progress {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "$/progress";
    type RegistrationOptions = ();
    type Params = super::structures::ProgressParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "$/progress");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                            SetTrace                                            //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#setTrace (Documentation)
pub enum SetTrace {}

impl NotificationTrait for SetTrace {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "$/setTrace";
    type RegistrationOptions = ();
    type Params = super::structures::SetTraceParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "$/setTrace");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                              Exit                                              //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The exit event is sent from the client to the server to
/// ask the server to exit its process.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#exit (Documentation)
pub enum Exit {}

impl NotificationTrait for Exit {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "exit";
    type RegistrationOptions = ();
    type Params = ();
    fn params(params: Self::Params) -> Option<Self::Params> {
        let _ = params;
        None
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "exit");
        debug_assert!(notification.params.is_none());
        Ok(())
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                          Initialized                                           //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The initialized notification is sent from the client to the
/// server after the client is fully initialized and the server
/// is allowed to send requests from the server to the client.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initialized (Documentation)
pub enum Initialized {}

impl NotificationTrait for Initialized {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "initialized";
    type RegistrationOptions = ();
    type Params = super::structures::InitializedParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "initialized");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                   NotebookDocumentDidChange                                    //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocument_didChange (Documentation)
pub enum NotebookDocumentDidChange {}

impl NotificationTrait for NotebookDocumentDidChange {
    const REGISTRATION_METHOD: Option<&'static str> = Some("notebookDocument/sync");
    const METHOD: &'static str = "notebookDocument/didChange";
    type RegistrationOptions = ();
    type Params = super::structures::DidChangeNotebookDocumentParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "notebookDocument/didChange");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                    NotebookDocumentDidClose                                    //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ A notification sent when a notebook closes.
///
/// @since 3.17.0
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocument_didClose (Documentation)
pub enum NotebookDocumentDidClose {}

impl NotificationTrait for NotebookDocumentDidClose {
    const REGISTRATION_METHOD: Option<&'static str> = Some("notebookDocument/sync");
    const METHOD: &'static str = "notebookDocument/didClose";
    type RegistrationOptions = ();
    type Params = super::structures::DidCloseNotebookDocumentParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "notebookDocument/didClose");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                    NotebookDocumentDidOpen                                     //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ A notification sent when a notebook opens.
///
/// @since 3.17.0
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocument_didOpen (Documentation)
pub enum NotebookDocumentDidOpen {}

impl NotificationTrait for NotebookDocumentDidOpen {
    const REGISTRATION_METHOD: Option<&'static str> = Some("notebookDocument/sync");
    const METHOD: &'static str = "notebookDocument/didOpen";
    type RegistrationOptions = ();
    type Params = super::structures::DidOpenNotebookDocumentParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "notebookDocument/didOpen");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                    NotebookDocumentDidSave                                     //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ A notification sent when a notebook document is saved.
///
/// @since 3.17.0
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocument_didSave (Documentation)
pub enum NotebookDocumentDidSave {}

impl NotificationTrait for NotebookDocumentDidSave {
    const REGISTRATION_METHOD: Option<&'static str> = Some("notebookDocument/sync");
    const METHOD: &'static str = "notebookDocument/didSave";
    type RegistrationOptions = ();
    type Params = super::structures::DidSaveNotebookDocumentParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "notebookDocument/didSave");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                         TelemetryEvent                                         //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ⬅️ The telemetry event notification is sent from the server to the client to ask
/// the client to log telemetry data.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#telemetry_event (Documentation)
pub enum TelemetryEvent {}

impl NotificationTrait for TelemetryEvent {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "telemetry/event";
    type RegistrationOptions = ();
    type Params = super::type_aliases::LspAny;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "telemetry/event");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                     TextDocumentDidChange                                      //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The document change notification is sent from the client to the server to signal
/// changes to a text document.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didChange (Documentation)
pub enum TextDocumentDidChange {}

impl NotificationTrait for TextDocumentDidChange {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "textDocument/didChange";
    type RegistrationOptions = super::structures::TextDocumentChangeRegistrationOptions;
    type Params = super::structures::DidChangeTextDocumentParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "textDocument/didChange");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                      TextDocumentDidClose                                      //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The document close notification is sent from the client to the server when
/// the document got closed in the client. The document's truth now exists where
/// the document's uri points to (e.g. if the document's uri is a file uri the
/// truth now exists on disk). As with the open notification the close notification
/// is about managing the document's content. Receiving a close notification
/// doesn't mean that the document was open in an editor before. A close
/// notification requires a previous open notification to be sent.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didClose (Documentation)
pub enum TextDocumentDidClose {}

impl NotificationTrait for TextDocumentDidClose {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "textDocument/didClose";
    type RegistrationOptions = super::structures::TextDocumentRegistrationOptions;
    type Params = super::structures::DidCloseTextDocumentParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "textDocument/didClose");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                      TextDocumentDidOpen                                       //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The document open notification is sent from the client to the server to signal
/// newly opened text documents. The document's truth is now managed by the client
/// and the server must not try to read the document's truth using the document's
/// uri. Open in this sense means it is managed by the client. It doesn't necessarily
/// mean that its content is presented in an editor. An open notification must not
/// be sent more than once without a corresponding close notification send before.
/// This means open and close notification must be balanced and the max open count
/// is one.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didOpen (Documentation)
pub enum TextDocumentDidOpen {}

impl NotificationTrait for TextDocumentDidOpen {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "textDocument/didOpen";
    type RegistrationOptions = super::structures::TextDocumentRegistrationOptions;
    type Params = super::structures::DidOpenTextDocumentParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "textDocument/didOpen");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                      TextDocumentDidSave                                       //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The document save notification is sent from the client to the server when
/// the document got saved in the client.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didSave (Documentation)
pub enum TextDocumentDidSave {}

impl NotificationTrait for TextDocumentDidSave {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "textDocument/didSave";
    type RegistrationOptions = super::structures::TextDocumentSaveRegistrationOptions;
    type Params = super::structures::DidSaveTextDocumentParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "textDocument/didSave");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                 TextDocumentPublishDiagnostics                                 //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ⬅️ Diagnostics notification are sent from the server to the client to signal
/// results of validation runs.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_publishDiagnostics (Documentation)
pub enum TextDocumentPublishDiagnostics {}

impl NotificationTrait for TextDocumentPublishDiagnostics {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "textDocument/publishDiagnostics";
    type RegistrationOptions = ();
    type Params = super::structures::PublishDiagnosticsParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "textDocument/publishDiagnostics");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                      TextDocumentWillSave                                      //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ A document will save notification is sent from the client to the server before
/// the document is actually saved.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_willSave (Documentation)
pub enum TextDocumentWillSave {}

impl NotificationTrait for TextDocumentWillSave {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "textDocument/willSave";
    type RegistrationOptions = super::structures::TextDocumentRegistrationOptions;
    type Params = super::structures::WillSaveTextDocumentParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "textDocument/willSave");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                        WindowLogMessage                                        //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ⬅️ The log message notification is sent from the server to the client to ask
/// the client to log a particular message.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#window_logMessage (Documentation)
pub enum WindowLogMessage {}

impl NotificationTrait for WindowLogMessage {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "window/logMessage";
    type RegistrationOptions = ();
    type Params = super::structures::LogMessageParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "window/logMessage");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                       WindowShowMessage                                        //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ⬅️ The show message notification is sent from a server to a client to ask
/// the client to display a particular message in the user interface.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#window_showMessage (Documentation)
pub enum WindowShowMessage {}

impl NotificationTrait for WindowShowMessage {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "window/showMessage";
    type RegistrationOptions = ();
    type Params = super::structures::ShowMessageParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "window/showMessage");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                  WindowWorkDoneProgressCancel                                  //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
/// initiated on the server side.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#window_workDoneProgress_cancel (Documentation)
pub enum WindowWorkDoneProgressCancel {}

impl NotificationTrait for WindowWorkDoneProgressCancel {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "window/workDoneProgress/cancel";
    type RegistrationOptions = ();
    type Params = super::structures::WorkDoneProgressCancelParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "window/workDoneProgress/cancel");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                WorkspaceDidChangeConfiguration                                 //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The configuration change notification is sent from the client to the server
/// when the client's configuration has changed. The notification contains
/// the changed configuration as defined by the language client.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_didChangeConfiguration (Documentation)
pub enum WorkspaceDidChangeConfiguration {}

impl NotificationTrait for WorkspaceDidChangeConfiguration {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "workspace/didChangeConfiguration";
    type RegistrationOptions = super::structures::DidChangeConfigurationRegistrationOptions;
    type Params = super::structures::DidChangeConfigurationParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "workspace/didChangeConfiguration");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                 WorkspaceDidChangeWatchedFiles                                 //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The watched files notification is sent from the client to the server when
/// the client detects changes to file watched by the language client.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_didChangeWatchedFiles (Documentation)
pub enum WorkspaceDidChangeWatchedFiles {}

impl NotificationTrait for WorkspaceDidChangeWatchedFiles {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "workspace/didChangeWatchedFiles";
    type RegistrationOptions = super::structures::DidChangeWatchedFilesRegistrationOptions;
    type Params = super::structures::DidChangeWatchedFilesParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "workspace/didChangeWatchedFiles");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                               WorkspaceDidChangeWorkspaceFolders                               //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
/// folder configuration changes.
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_didChangeWorkspaceFolders (Documentation)
pub enum WorkspaceDidChangeWorkspaceFolders {}

impl NotificationTrait for WorkspaceDidChangeWorkspaceFolders {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "workspace/didChangeWorkspaceFolders";
    type RegistrationOptions = ();
    type Params = super::structures::DidChangeWorkspaceFoldersParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "workspace/didChangeWorkspaceFolders");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                    WorkspaceDidCreateFiles                                     //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The did create files notification is sent from the client to the server when
/// files were created from within the client.
///
/// @since 3.16.0
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_didCreateFiles (Documentation)
pub enum WorkspaceDidCreateFiles {}

impl NotificationTrait for WorkspaceDidCreateFiles {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "workspace/didCreateFiles";
    type RegistrationOptions = super::structures::FileOperationRegistrationOptions;
    type Params = super::structures::CreateFilesParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "workspace/didCreateFiles");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                    WorkspaceDidDeleteFiles                                     //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The will delete files request is sent from the client to the server before files are actually
/// deleted as long as the deletion is triggered from within the client.
///
/// @since 3.16.0
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_didDeleteFiles (Documentation)
pub enum WorkspaceDidDeleteFiles {}

impl NotificationTrait for WorkspaceDidDeleteFiles {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "workspace/didDeleteFiles";
    type RegistrationOptions = super::structures::FileOperationRegistrationOptions;
    type Params = super::structures::DeleteFilesParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "workspace/didDeleteFiles");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //
//                                    WorkspaceDidRenameFiles                                     //
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ //

/// [📖][docs] ➡️ The did rename files notification is sent from the client to the server when
/// files were renamed from within the client.
///
/// @since 3.16.0
///
/// [docs]: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_didRenameFiles (Documentation)
pub enum WorkspaceDidRenameFiles {}

impl NotificationTrait for WorkspaceDidRenameFiles {
    const REGISTRATION_METHOD: Option<&'static str> = None;
    const METHOD: &'static str = "workspace/didRenameFiles";
    type RegistrationOptions = super::structures::FileOperationRegistrationOptions;
    type Params = super::structures::RenameFilesParams;
    fn params(params: Self::Params) -> Option<Self::Params> {
        Some(params)
    }
    fn deserialize(notification: Notification<Value>) -> std::io::Result<Self::Params> {
        debug_assert!(notification.method == "workspace/didRenameFiles");
        Ok(serde_json::from_value(
            notification.params.ok_or_else(missing_params)?,
        )?)
    }
}
